# 设计模式
学习记录，Demo

### 6大设计原则

##### 单一原则

1、描述：

    就一个类而言，应该只有一个引起他变化的原因。（单一职责适用于接口、类，同时也适用于方法）

2、优点：

    类的复杂性降低，实现什么职责都有清晰明确的定义；
    可读性提高，复杂性降低，那当然可读性提高了；
    可维护性提高，可读性提高，那当然更容易维护了；
    变更引起的风险降低，如果接口的单一职责做得好，一个接口修改只对相应的实现类有影响，对其他的接口无影响，这对系统的扩展性、维护性都有非常大的帮助。

3、不遵守会存在的问题：

    如果一个类承担的职责过多，就等于把这些职责耦合在一起，一个职责的变化可能会削弱或者抑制这个类完成其他职责的能力。
    这种耦合会导致脆弱的设计，当变化发生时，设计会遭受到意想不到的破坏[ASD]

4、如何做到：

    建议所有接口、方法一定要做到单一职责，类的设计尽量做到只有一个原因引起变化。 
    软件设计真正要做的许多内容，就是发现职责并把那些职责相互分离[ASD]。
    如果你能够想到多于一个的动机去改变一个类，那么这个类就具有多于一个的职责[ASD]，就应该考虑类的职责分离。
    例如：游戏的逻辑就应该与界面进行分离。

##### 开闭原则
1、描述：

    对于软件实体（类，模块，函数等）应该允许扩展，但是不可以修改。（对扩展是开放的，对修改是封闭的）

2、优点：

    面对需求的改变却可以保持相对稳定，从而使得系统可以在第一个版本以后不断推出新的版本。
    开放-封闭原则是面向对象设计的核心所在。遵循这个原则可以带来面向对象技术所声称的巨大好处，也就是可维护、可扩展、可复用、灵活性好。开发人员应该仅对程序中呈现出频繁变化的那些部分做出抽象，然而，对于应用程序中的每个部分都刻意地进行抽象同样不是一个好主意。拒绝不成熟的抽象和抽象本身一样重要[ASD]。
 
3、不遵守会存在的问题：

    面对需求的改变越来越多，难以保持相对稳定，到后期可能导致项目维护困难重重。

4、如何做到：

    面对需求，对程序的改动是通过增加新代码进行的，而不是更改现有的代码[ASD]。 

    绝对的对修改关闭是不可能的。无论模块是多么的‘封闭’，都会存在一些无法对之封闭的变化。既然不可能完全封闭，设计人员必须对于他设计的模块应该对哪种变化封闭做出选择。他必须先猜测出最有可能发生的变化种类，然后构造抽象来隔离那些变化[ASD]。

    我们是很难预先猜测，但我们却可以在发生小变化时，就及早去想办法应对发生更大变化的可能。也就是说，等到变化发生时立即采取行动[ASD]。
 
    在我们最初编写代码时，假设变化不会发生。当变化发生时，我们就创建抽象来隔离以后发生的同类变化[ASD]。

    例如：在收费例子中，使用简单工厂模式创建不同的收费类（正常，打折。返利），但这个模式只是解决对象的创建问题。
    由于工厂本身包括了所有的收费方式，商场是可能经常性地更改打折额度和返利额度，每次维护或扩展收费方式都要改动这个工厂。为了解决这个问题，使用简单工厂与策略模式结合来解决。简单工厂模式需要让客户端认识两个类，CashSuper和CashFactory，而策略模式与简单工厂结合的用法，客户端就只需要认识一个类CashContext就可以了。
 
##### 里氏替换原则
1、描述：

    子类型必须能够替换掉他们的父类型

2、优点：

    只有当子类可以替换掉父类，软件单位的功能不受到影响时，父类才能真正被复用，而子类也能够在父类的基础上增加新的行为。
    由于子类型的可替换性才使得使用父类类型的模块在无需修改的情况下就可以扩展。

3、不遵守会存在的问题：

    如果子类不能替换父类，那么就无法实现继承复用。

4、如何做到：

    在项目中，采用里氏替换原则时，尽量避免子类的“个性”，一旦子类有“个性”，这个子类和父类之间的关系就很难调和了，把子类当做父类使用，子类的“个性”被抹杀——委屈了点；把子类单独作为一个业务来使用，则会让代码间的耦合关系变得扑朔迷离——缺乏类替换的标准。

    注意： 如果子类不能完整地实现父类的方法，或者父类的某些方法在子类中已经发生“畸变”，则建议断开父子继承关系，采用依赖、聚集、组合等关系代替继承。

##### 依赖倒置原则
1、描述：

    高层模块不应该依赖低层模块，两者都应该依赖其抽象；抽象不应该依赖细节；细节应该依赖抽象。
    Java语言中的表现就是：
        模块间的依赖通过抽象发生，实现类之间不发生直接的依赖关系，其依赖关系是通过接口或抽象类产生的；
        接口或抽象类不依赖于实现类；
        实现类依赖接口或抽象类。
        更加精简的定义就是“面向接口编程”——OOD（Object-Oriented Design，面向对象设计）的精髓之一。

2、优点：

    可以减少类间的耦合性，提高系统的稳定性，降低并行开发引起的风险，提高代码的可读性和可维护性。

3、不遵守会存在的问题：

    类之间耦合性高，稳定性下降，并行开发风险大，维护性差。

4、如何做到：

    面向接口编程。
    例如：k线图组件开发，组件一些必要的数据使用接口协议定义，让使用该组件的模块实现这些必要的接口，从而让k线图组件获得绘制k线所需的必要数据。这样就避免了k线图组件对使用该组件的数据依赖，降低了耦合性。

##### 接口隔离原则
1、描述：

    客户端不应该依赖它不需要的接口；类间的依赖关系应该建立在最小的接口上。
    接口隔离原则与单一职责的审视角度是不相同的，单一职责要求的是类和接口职责单一，注重的是职责，这是业务逻辑上的划分，而接口隔离原则要求接口的方法尽量少。

2、优点：

    接口的方法尽量少。

3、不遵守会存在的问题：

    有缺陷。如果一个接口过于庞大了，容纳了一些可变的因素，而实现接口的类并不想将全部方法实现，这时候这个接口就封装过度了。

4、如何做到：

    接口尽量细化，同时接口中的方法尽量少；
    一个接口只服务于一个子模块或业务逻辑；
    已经被污染了的接口，尽量去修改，若变更的风险较大，则采用适配器模式进行转化处理；

    例如：星探搜索美女的例子。气质型、外貌型这2种类型的特质都属于美女，但是不同类型的特质（脸好看，身材好，气质好）就应该在不同的接口。外貌接口：脸好看，身材好； 气质接口：气质好。

##### 迪米特原则
1、描述：

    如果两个类不必彼此直接通信，那么这两个类就不应该发生直接t的相互作用。如果其中一个类需要调用另外一个类的某一个方法，可以通过第三者转发这个调用。

    一个对象应该对其他对象有最少的了解。通俗地讲，一个类应该对自己需要耦合或调用的类知道得最少，你（被耦合或调用的类）的内部是如何复杂都和我没关系，那是你的事情，我就知道你提供的这么多public方法，我就调用这么多，其他的我一概不关心。

2、优点： 

    迪米特法则的核心观念就是类间解耦，弱耦合，只有弱耦合了以后，类的复用率才可以提高

3、不遵守会存在的问题：

    类之间耦合过高，无法复用。

4、如何做到：

    一个类只和朋友交流，不与陌生类交流，不要出现getA().getB().getC().getD()这种情况（在一种极端的情况下允许出现这种访问，即每一个点号后面的返回类型都相同），类与类之间的关系是建立在类间的，而不是方法间，因此一个方法尽量不引入一个类中不存在的对象，当然，JDK API提供的类除外。
    例如：老师要体育委员清点女生人数。老师只要依赖体育委员，让体育委员去依赖女生。


### 创建型设计模式 
    对象实例化的模式，创建型模式用于解耦对象的实例化过程

##### 简单工厂模式 *
1、描述：
    
    用一个单独的类来做这个创造实例的过程。根据客户端的选择条件动态实例化相关的类。

2、优缺点：

    a.简单工厂模式的最大优点在于工厂类中包含了必要的逻辑判断，根据客户端的选择条件动态实例化相关的类，对于客户端来说，去除了与具体产品的依赖。
    b.违背了开放-封闭原则。因为要增加新的运算，必须修改工厂内部的switch分支。

3、举例：

    简单的计算器实现。传入不同操作符，创建不同的运算类。

##### 工厂方法模式 *
1、描述：

    定义一个用于创建对象的接口，让子类决定实例化哪一个类。工厂方法使一个类的实例化延迟到其子类。
    相比简单工厂，工厂方法把简单工厂的内部逻辑判断移到了客户端代码来进行。这样想增加功能时，本来是修改工厂的，现在只需要修改客户端。
 
2、优缺点：

    工厂方法克服了简单工厂违背开放-封闭原则的缺点，又保持了封装对象创建过程的优点。

3、举例：

    简单的计算器实现。遵守开放-封闭原则，增加计算类。

##### 抽象工厂模式 * 
1、描述：

    提供一个创建一系列相关或相互依赖对象的接口，而无需指定他们的类。

2、优缺点：

    a.最大的好处便是易于交换产品系列，由于具体工厂类，例如IFactory factory = new AccessFactory（），在一个应用中只需要在初始化的时候出现一次，这就使得改变一个应用的具体工厂变得非常容易，它只需要改变具体工厂即可使用不同的产品配置。
    b.它让具体的创建实例过程与客户端分离，客户端是通过它们的抽象接口操纵实例，产品的具体类名也被具体工厂的实现分离，不会出现在客户代码中。
    c.增加功能时，需要更改的地方多，不利于扩展。

3、举例：

    数据库替换的例子。
    

##### 单利模式 *
1、描述：

    一个类仅有一个实例，并提供一个访问他的全局访问点。
    懒汉式：第一次被引用时，才会将自己实例化。
    饿汉式：自己被加载时就实例化。

2、优缺点：

    a.可以保证唯一的实例
    b.可以严格地控制客户怎样访问它以及何时访问它。简单地说就是对唯一实例的受控访问。

3、举例：

    需要确保一个实例在应用中只有一个实例时可以使用。
    例如：SDWebImage中的 SDWebImageManager 等。

##### 建造者模式 *
1、描述：

    将一个复杂对象的构建与他的表示分离，使得同样的构建过程可以创建不同的表示。注意建造者模式要求建造的过程必须是稳定的。
    在Android开发中见得多一些。

2、优缺点：

    a.封装性
    b.建造者独立，容易扩展
    c.便于控制细节风险

3、举例：
    相同的方法，不同的执行顺序，产生不同的事件结果时，可以采用建造者模式。
    多个部件或零件，都可以装配到一个对象中，但是产生的运行结果又不相同时，则可以使用该模式。
    产品类非常复杂，或者产品类中的调用顺序不同产生了不同的效能，这个时候使用建造者模式非常合适。
    建造者模式关注的是零件类型和装配工艺（顺序），这是它与工厂方法模式最大不同的地方，虽然同为创建类模式，但是注重点不同。
    例如：
        a.构建Person，将Person的创建和person对象属性的设置分离。

##### 原型模式 *
1、描述：

    用原型实例指定创建对象的种类，并且通过拷贝这些原型创建新的对象。
    简单来说，就是从一个对象再创建另外一个可定制的对象，而且不需知道任何创建的细节。

    浅复制：指针拷贝，源对象和副本指向的是同一个对象。
    深复制：内容拷贝，源对象和副本指向的是不同的两个对象。

    对应iOS中的copy，mutableCopy.只有对不可变对象进行copy操作才是浅复制，其他拷贝都是深复制。

2、优缺点：

    a.每NEW一次，都需要执行一次构造函数，如果构造函数的执行时间很长，那么多次的执行这个初始化操作就实在是太低效了。一般在初始化的信息不发生变化的情况下，克隆是最好的办法。这既隐藏了对象创建的细节，又对性能是大大的提高.

3、举例：

    a.深复制：简历复印。
    b.浅复制：数据集对象DataSet，它就有Clone（）方法和Copy（）方法，Clone（）方法用来复制DataSet的结构，但不复制DataSet的数据。
    c.深复制：Copy（）方法不但复制结构，也复制数据。

### 结构型设计模式 
    把类或对象结合在一起形成一个更大的结构

##### 适配器模式 *
1、描述：

    将一个类的接口转换成客户希望的另外一个接口。Adapter模式使得原本由于接口不兼容而不能一起工作的哪些类可以一起工作。

2、优缺点：

    a.适配器模式可以让两个没有任何关系的类在一起运行，只要适配器这个角色能够搞定他们就成。
    b.增加了类的透明性
    c.提高了类的复用度
    d.灵活性非常好

3、举例：

    你有动机修改一个已经投产中的接口时，适配器模式可能是最适合你的模式。
    比如系统扩展了，需要使用一个已有或新建立的类，但这个类又不符合系统的接口，怎么办？使用适配器模式。
    例如：
        员工信息管理，内外部员工信息接口不匹配，可使用适配器模式将外部员工信息接口转换成内部员工信息匹配的接口。
        姚明打NBA时交流，需要翻译

##### 装饰器模式 *
1、描述：

    动态的给一个对象添加一些额外的职责，就增加功能来说，装饰模式比生成子类更为灵活。

    在iOS中Category就有该模式作用。

2、优缺点：

    a.可以动态的给一个对象添加一些额外的职责，而不需要修改原来的类。就增加功能来说，装饰模式比生成子类更为灵活。
    b.把类中的装饰功能从类中搬移去除，这样可以简化原有的类。
    c.有效地把类的核心职责和装饰功能区分开了。而且可以去除相关类中重复的装饰逻辑。

3、举例：

    a.成绩单例子，不修改原来报告单的情况下，新增排名和高分打印的方法。
    b.小菜扮靓例子，这个例子感觉不太形象。

##### 代理模式 *
1、描述：

    为其他对象提供一种代理以控制对这个对象的访问。

2、优缺点：

    a.职责清晰
    b.高扩展性
    c.智能化

3、举例：

    代理模式应用得非常广泛，大到一个系统框架、企业平台，小到代码片段、事务处理，稍不留意就用到代理模式。
    例如：
        a.游戏代练，为玩家提供一个代练，这个代练来替玩家打游戏。
        b.租客 —— 中介 —— 房东

##### 外观模式
1、描述：

2、优缺点：

3、举例：

##### 桥接模式
1、描述：

2、优缺点：

3、举例：

##### 组合模式
1、描述：

2、优缺点：

3、举例：

##### 享元模式
1、描述：

2、优缺点：

3、举例：


### 行为型设计模式 
    类和对象如何交互，及划分责任和算法

##### 策略模式 *
1、描述：

    策略模式定义了算法家族，分别封装起来，让它们之间可以互相替换，此模式让算法的变化，不会影响到使用算法的客户。
    配合简单工厂模式使用可以把一些必要的逻辑判断封装起来。

2、优缺点：

    a.算法可以自由切换
    b.避免使用多重条件判断
    c.策略类数量增多

3、举例：

    使用场景：
    a.多个类只有在算法或行为上稍有不同的场景。
    b.算法需要自由切换的场景。（算法的选择是由使用者决定的，或者算法始终在进化）
    c.需要屏蔽算法规则的场景。（太多的算法你只要知道一个名字就可以了，传递相关的数字进来，反馈一个运算结果，万事大吉）

    例如：
    a.商品打折计算结算金额，不同的打折方式就可认为是不同的算法。
    b.播放器播放音频列表，由于不同的播放模式，通过算法计算不同的音频列表。

##### 模板方法模式
1、描述：

2、优缺点：

3、举例：

##### 观察者模式 *
1、描述：

    定义一种一对多的依赖关系，让多个观察者对象同时监听某一个主题对象。这个主题对象在状态发生改变时，会通知所有观察者对象，使他们能够自动更新自己。

2、优缺点：

    a.观察者和被观察者之间是抽象耦合
    b.建立一套触发机制
    c.多个观察者，开发和调试就会比较复杂，而且在Java中消息的通知默认是顺序执行，一个观察者卡壳，会影响整体的执行效率。在这种情况下，一般考虑采用异步的方式。
    d.多级触发时的效率更是让人担忧，大家在设计时注意考虑。

3、举例：

    a.员工观察上级，发现上级立即认真工作。
    b.电台在广播，你可以打开一个收音机，或者两个收音机来收听，电台就是被观察者，收音机就是观察者。

##### 迭代子模式
1、描述：

2、优缺点：

3、举例：

##### 责任链模式
1、描述：

2、优缺点：

3、举例：

##### 命令模式
1、描述：

2、优缺点：

3、举例：

##### 备忘录模式 *
1、描述：

    在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态。这样以后就可将该对象恢复到原先保存的状态。

2、优缺点：

    可以保存一个对象的状态。

3、举例：

    需要保存和恢复数据的相关状态场景。提供一个可回滚（rollback）的操作；

    例如：保存游戏进度，Word中的CTRL+Z组合键，IE浏览器中的后退按钮，文件管理器上的backspace键等。
    
##### 状态模式
1、描述：

2、优缺点：

3、举例：

##### 访问者模式
1、描述：

2、优缺点：

3、举例：

##### 中介者模式
1、描述：

2、优缺点：

3、举例：

##### 解释器模式
1、描述：

2、优缺点：

3、举例：
