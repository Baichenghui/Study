# 设计模式
学习记录，Demo

### 6大设计原则

##### 单一原则

1、描述：

    就一个类而言，应该只有一个引起他变化的原因。（单一职责适用于接口、类，同时也适用于方法）

2、优点：

    类的复杂性降低，实现什么职责都有清晰明确的定义；
    可读性提高，复杂性降低，那当然可读性提高了；
    可维护性提高，可读性提高，那当然更容易维护了；
    变更引起的风险降低，如果接口的单一职责做得好，一个接口修改只对相应的实现类有影响，对其他的接口无影响，这对系统的扩展性、维护性都有非常大的帮助。

3、不遵守会存在的问题：

    如果一个类承担的职责过多，就等于把这些职责耦合在一起，一个职责的变化可能会削弱或者抑制这个类完成其他职责的能力。
    这种耦合会导致脆弱的设计，当变化发生时，设计会遭受到意想不到的破坏[ASD]

4、如何做到：

    建议所有接口、方法一定要做到单一职责，类的设计尽量做到只有一个原因引起变化。 
    软件设计真正要做的许多内容，就是发现职责并把那些职责相互分离[ASD]。
    如果你能够想到多于一个的动机去改变一个类，那么这个类就具有多于一个的职责[ASD]，就应该考虑类的职责分离。
    例如：游戏的逻辑就应该与界面进行分离。

##### 开闭原则
1、描述：

    对于软件实体（类，模块，函数等）应该允许扩展，但是不可以修改。（对扩展是开放的，对修改是封闭的）

2、优点：

    面对需求的改变却可以保持相对稳定，从而使得系统可以在第一个版本以后不断推出新的版本。
    开放-封闭原则是面向对象设计的核心所在。遵循这个原则可以带来面向对象技术所声称的巨大好处，也就是可维护、可扩展、可复用、灵活性好。开发人员应该仅对程序中呈现出频繁变化的那些部分做出抽象，然而，对于应用程序中的每个部分都刻意地进行抽象同样不是一个好主意。拒绝不成熟的抽象和抽象本身一样重要[ASD]。
 
3、不遵守会存在的问题：

    面对需求的改变越来越多，难以保持相对稳定，到后期可能导致项目维护困难重重。

4、如何做到：

    面对需求，对程序的改动是通过增加新代码进行的，而不是更改现有的代码[ASD]。 

    绝对的对修改关闭是不可能的。无论模块是多么的‘封闭’，都会存在一些无法对之封闭的变化。既然不可能完全封闭，设计人员必须对于他设计的模块应该对哪种变化封闭做出选择。他必须先猜测出最有可能发生的变化种类，然后构造抽象来隔离那些变化[ASD]。

    我们是很难预先猜测，但我们却可以在发生小变化时，就及早去想办法应对发生更大变化的可能。也就是说，等到变化发生时立即采取行动[ASD]。
 
    在我们最初编写代码时，假设变化不会发生。当变化发生时，我们就创建抽象来隔离以后发生的同类变化[ASD]。

    例如：在收费例子中，使用简单工厂模式创建不同的收费类（正常，打折。返利），但这个模式只是解决对象的创建问题。
    由于工厂本身包括了所有的收费方式，商场是可能经常性地更改打折额度和返利额度，每次维护或扩展收费方式都要改动这个工厂。为了解决这个问题，使用简单工厂与策略模式结合来解决。简单工厂模式需要让客户端认识两个类，CashSuper和CashFactory，而策略模式与简单工厂结合的用法，客户端就只需要认识一个类CashContext就可以了。
 
##### 里氏替换原则
1、描述：

    子类型必须能够替换掉他们的父类型

2、优点：

    只有当子类可以替换掉父类，软件单位的功能不受到影响时，父类才能真正被复用，而子类也能够在父类的基础上增加新的行为。
    由于子类型的可替换性才使得使用父类类型的模块在无需修改的情况下就可以扩展。

3、不遵守会存在的问题：

    如果子类不能替换父类，那么就无法实现继承复用。

4、如何做到：

    在项目中，采用里氏替换原则时，尽量避免子类的“个性”，一旦子类有“个性”，这个子类和父类之间的关系就很难调和了，把子类当做父类使用，子类的“个性”被抹杀——委屈了点；把子类单独作为一个业务来使用，则会让代码间的耦合关系变得扑朔迷离——缺乏类替换的标准。

    注意： 如果子类不能完整地实现父类的方法，或者父类的某些方法在子类中已经发生“畸变”，则建议断开父子继承关系，采用依赖、聚集、组合等关系代替继承。

##### 依赖倒置原则
1、描述：

    高层模块不应该依赖低层模块，两者都应该依赖其抽象；抽象不应该依赖细节；细节应该依赖抽象。
    Java语言中的表现就是：
        模块间的依赖通过抽象发生，实现类之间不发生直接的依赖关系，其依赖关系是通过接口或抽象类产生的；
        接口或抽象类不依赖于实现类；
        实现类依赖接口或抽象类。
        更加精简的定义就是“面向接口编程”——OOD（Object-Oriented Design，面向对象设计）的精髓之一。

2、优点：

    可以减少类间的耦合性，提高系统的稳定性，降低并行开发引起的风险，提高代码的可读性和可维护性。

3、不遵守会存在的问题：

    类之间耦合性高，稳定性下降，并行开发风险大，维护性差。

4、如何做到：

    面向接口编程。
    例如：k线图组件开发，组件一些必要的数据使用接口协议定义，让使用该组件的模块实现这些必要的接口，从而让k线图组件获得绘制k线所需的必要数据。这样就避免了k线图组件对使用该组件的数据依赖，降低了耦合性。

##### 接口隔离原则
1、描述：

    客户端不应该依赖它不需要的接口；类间的依赖关系应该建立在最小的接口上。
    接口隔离原则与单一职责的审视角度是不相同的，单一职责要求的是类和接口职责单一，注重的是职责，这是业务逻辑上的划分，而接口隔离原则要求接口的方法尽量少。

2、优点：

    接口的方法尽量少。

3、不遵守会存在的问题：

    有缺陷。如果一个接口过于庞大了，容纳了一些可变的因素，而实现接口的类并不想将全部方法实现，这时候这个接口就封装过度了。

4、如何做到：

    接口尽量细化，同时接口中的方法尽量少；
    一个接口只服务于一个子模块或业务逻辑；
    已经被污染了的接口，尽量去修改，若变更的风险较大，则采用适配器模式进行转化处理；

    例如：星探搜索美女的例子。气质型、外貌型这2种类型的特质都属于美女，但是不同类型的特质（脸好看，身材好，气质好）就应该在不同的接口。外貌接口：脸好看，身材好； 气质接口：气质好。

##### 迪米特原则
1、描述：

    如果两个类不必彼此直接通信，那么这两个类就不应该发生直接t的相互作用。如果其中一个类需要调用另外一个类的某一个方法，可以通过第三者转发这个调用。

    一个对象应该对其他对象有最少的了解。通俗地讲，一个类应该对自己需要耦合或调用的类知道得最少，你（被耦合或调用的类）的内部是如何复杂都和我没关系，那是你的事情，我就知道你提供的这么多public方法，我就调用这么多，其他的我一概不关心。

2、优点： 

    迪米特法则的核心观念就是类间解耦，弱耦合，只有弱耦合了以后，类的复用率才可以提高

3、不遵守会存在的问题：

    类之间耦合过高，无法复用。

4、如何做到：

    一个类只和朋友交流，不与陌生类交流，不要出现getA().getB().getC().getD()这种情况（在一种极端的情况下允许出现这种访问，即每一个点号后面的返回类型都相同），类与类之间的关系是建立在类间的，而不是方法间，因此一个方法尽量不引入一个类中不存在的对象，当然，JDK API提供的类除外。
    例如：老师要体育委员清点女生人数。老师只要依赖体育委员，让体育委员去依赖女生。


### 创建型设计模式 
    对象实例化的模式，创建型模式用于解耦对象的实例化过程

##### 简单工厂模式 *
1、描述：
    
    用一个单独的类来做这个创造实例的过程。根据客户端的选择条件动态实例化相关的类。

2、优缺点：

    a.简单工厂模式的最大优点在于工厂类中包含了必要的逻辑判断，根据客户端的选择条件动态实例化相关的类，对于客户端来说，去除了与具体产品的依赖。
    b.违背了开放-封闭原则。因为要增加新的运算，必须修改工厂内部的switch分支。

3、举例：

    简单的计算器实现。传入不同操作符，创建不同的运算类。

##### 工厂方法模式 *
1、描述：

    定义一个用于创建对象的接口，让子类决定实例化哪一个类。工厂方法使一个类的实例化延迟到其子类。
    相比简单工厂，工厂方法把简单工厂的内部逻辑判断移到了客户端代码来进行。这样想增加功能时，本来是修改工厂的，现在只需要修改客户端。
 
2、优缺点：

    工厂方法克服了简单工厂违背开放-封闭原则的缺点，又保持了封装对象创建过程的优点。

3、举例：

    简单的计算器实现。遵守开放-封闭原则，增加计算类。

##### 抽象工厂模式 * 
1、描述：

    提供一个创建一系列相关或相互依赖对象的接口，而无需指定他们的类。
    与工厂模式区别：一个是提供一个创建对象的接口，另一个是提供一个创建一系列对象的接口

2、优缺点：

    a.最大的好处便是易于交换产品系列，由于具体工厂类，例如IFactory factory = new AccessFactory（），在一个应用中只需要在初始化的时候出现一次，这就使得改变一个应用的具体工厂变得非常容易，它只需要改变具体工厂即可使用不同的产品配置。
    b.它让具体的创建实例过程与客户端分离，客户端是通过它们的抽象接口操纵实例，产品的具体类名也被具体工厂的实现分离，不会出现在客户代码中。
    c.增加功能时，需要更改的地方多，不利于扩展。

3、举例：

    数据库替换的例子。
    

##### 单利模式 * 
1、描述：

    一个类仅有一个实例，并提供一个访问他的全局访问点。
    懒汉式：第一次被引用时，才会将自己实例化。
    饿汉式：自己被加载时就实例化。

2、优缺点：

    a.可以保证唯一的实例
    b.可以严格地控制客户怎样访问它以及何时访问它。简单地说就是对唯一实例的受控访问。

3、举例：

    需要确保一个实例在应用中只有一个实例时可以使用。
    例如：SDWebImage中的 SDWebImageManager 等。

##### 建造者模式 *
1、描述：

    将一个复杂对象的构建与他的表示分离，使得同样的构建过程可以创建不同的表示。注意建造者模式要求建造的过程必须是稳定的。
    在Android开发中见得多一些。

2、优缺点：

    a.封装性
    b.建造者独立，容易扩展
    c.便于控制细节风险

3、举例：
    相同的方法，不同的执行顺序，产生不同的事件结果时，可以采用建造者模式。
    多个部件或零件，都可以装配到一个对象中，但是产生的运行结果又不相同时，则可以使用该模式。
    产品类非常复杂，或者产品类中的调用顺序不同产生了不同的效能，这个时候使用建造者模式非常合适。
    建造者模式关注的是零件类型和装配工艺（顺序），这是它与工厂方法模式最大不同的地方，虽然同为创建类模式，但是注重点不同。
    例如：
        a.构建Person，将Person的创建和person对象属性的设置分离。

##### 原型模式 *
1、描述：

    用原型实例指定创建对象的种类，并且通过拷贝这些原型创建新的对象。
    简单来说，就是从一个对象再创建另外一个可定制的对象，而且不需知道任何创建的细节。

    浅复制：指针拷贝，源对象和副本指向的是同一个对象。
    深复制：内容拷贝，源对象和副本指向的是不同的两个对象。

    对应iOS中的copy，mutableCopy.只有对不可变对象进行copy操作才是浅复制，其他拷贝都是深复制。

2、优缺点：

    a.每NEW一次，都需要执行一次构造函数，如果构造函数的执行时间很长，那么多次的执行这个初始化操作就实在是太低效了。一般在初始化的信息不发生变化的情况下，克隆是最好的办法。这既隐藏了对象创建的细节，又对性能是大大的提高.

3、举例：

    a.深复制：简历复印。
    b.浅复制：数据集对象DataSet，它就有Clone（）方法和Copy（）方法，Clone（）方法用来复制DataSet的结构，但不复制DataSet的数据。
    c.深复制：Copy（）方法不但复制结构，也复制数据。

### 结构型设计模式 
    把类或对象结合在一起形成一个更大的结构

##### 适配器模式 *
1、描述：

    将一个类的接口转换成客户希望的另外一个接口。Adapter模式使得原本由于接口不兼容而不能一起工作的哪些类可以一起工作。

2、优缺点：

    a.适配器模式可以让两个没有任何关系的类在一起运行，只要适配器这个角色能够搞定他们就成。
    b.增加了类的透明性
    c.提高了类的复用度
    d.灵活性非常好

3、举例：

    你有动机修改一个已经投产中的接口时，适配器模式可能是最适合你的模式。
    比如系统扩展了，需要使用一个已有或新建立的类，但这个类又不符合系统的接口，怎么办？使用适配器模式。
    例如：
        员工信息管理，内外部员工信息接口不匹配，可使用适配器模式将外部员工信息接口转换成内部员工信息匹配的接口。
        姚明打NBA时交流，需要翻译

##### 装饰器模式 *
1、描述：

    动态的给一个对象添加一些额外的职责，就增加功能来说，装饰模式比生成子类更为灵活。

    在iOS中Category就有该模式作用。

2、优缺点：

    a.可以动态的给一个对象添加一些额外的职责，而不需要修改原来的类。就增加功能来说，装饰模式比生成子类更为灵活。
    b.把类中的装饰功能从类中搬移去除，这样可以简化原有的类。
    c.有效地把类的核心职责和装饰功能区分开了。而且可以去除相关类中重复的装饰逻辑。

3、举例：

    a.成绩单例子，不修改原来报告单的情况下，新增排名和高分打印的方法。
    b.小菜扮靓例子，这个例子感觉不太形象。

##### 代理模式 *
1、描述：

    为其他对象提供一种代理以控制对这个对象的访问。

2、优缺点：

    a.职责清晰
    b.高扩展性
    c.智能化

3、举例：

    代理模式应用得非常广泛，大到一个系统框架、企业平台，小到代码片段、事务处理，稍不留意就用到代理模式。
    例如：
        a.游戏代练，为玩家提供一个代练，这个代练来替玩家打游戏。
        b.租客 —— 中介 —— 房东

##### 外观模式
1、描述：

    为子系统中的一组接口提供一个一致的界面，此模式定义了一个高层接口，这个接口使得这一子系统更加容易使用。

2、优缺点：

    a、在设计初期阶段，应该要有意识的将不同的两个层分离，比如经典的三层架构，就需要考虑在数据访问层和业务逻辑层、业务逻辑层和表示层的层与层之间建立外观Facade，这样可以为复杂的子系统提供一个简单的接口，使得耦合大大降低。
    b、在开发阶段，子系统往往因为不断的重构演化而变得越来越复杂，大多数的模式使用时也都会产生很多很小的类，这本是好事，但也给外部调用它们的用户程序带来了使用上的困难，增加外观Facade可以提供一个简单的接口，减少它们之间的依赖
    c、在维护一个遗留的大型系统时，可能这个系统已经非常难以维护和扩展了，但因为它包含非常重要的功能，新的需求开发必须要依赖于它。此时用外观模式Facade也是非常合适的。你可以为新系统开发一个外观Facade类，来提供设计粗糙或高度复杂的遗留代码的比较清晰简单的接口，让新系统与Facade对象交互，Facade与遗留代码交互所有复杂的工作。

3、举例：

    例如：
        投资者想买股票但是自己不懂，所以就买基金，基金买股票。

##### 桥接模式
1、描述：

    将抽象部分与它的实现部分分离，使它们都可以独立的变化。

    使用了聚合的设计原则

2、优缺点：

    a、抽象和实现分离
    b、优秀的扩展能力
    c、实现细节对客户透明    

3、举例：

    a、不希望或不适合使用继承的场景
    b、接口与抽象类不稳定的场景
    c、重要性要求较高的场景

    例如：手机品牌和手机软件的例子。不同手机品牌有各种手机软件。

##### 组合模式
1、描述：

    将对象组合成树形结构以表示’部分 - 整体‘的层次结构。组合模式使得用户对单个对象和组合对象的使用具有一致性。

2、优缺点：

    a、组合模式让客户可以一致地使用组合结构和单个对象

3、举例：

    当你发现需求中是体现部分与整体层次的结构时，以及你希望用户可以忽略组合对象与单个对象的不同，统一地使用组合结构中的所有对象时，就应该考虑用组合模式了。

    例如：公司管理系统。公司下面有各个部门

##### 享元模式
1、描述：

    运用共享技术有效地支持大量细粒度的对象。

2、优缺点：

    享元模式是一个非常简单的模式，它可以大大减少应用程序创建的对象，降低程序内存的占用，增强程序的性能，但它同时也提高了系统复杂性，需要分离出外部状态和内部状态，而且外部状态具有固化特性，不应该随内部状态改变而改变，否则导致系统的逻辑混乱。

3、举例：

    a、系统中存在大量的相似对象。
    b、细粒度的对象都具备较接近的外部状态，而且内部状态与环境无关，也就是说对象没有特定身份。
    c、需要缓冲池的场景。

    例如：项目多页别傻做的例子。相同类型的网站归为一类共享一份代码。

### 行为型设计模式 
    类和对象如何交互，及划分责任和算法

##### 策略模式 *
1、描述：

    策略模式定义了算法家族，分别封装起来，让它们之间可以互相替换，此模式让算法的变化，不会影响到使用算法的客户。
    配合简单工厂模式使用可以把一些必要的逻辑判断封装起来。

2、优缺点：

    a.算法可以自由切换
    b.避免使用多重条件判断
    c.策略类数量增多

3、举例：

    使用场景：
    a.多个类只有在算法或行为上稍有不同的场景。
    b.算法需要自由切换的场景。（算法的选择是由使用者决定的，或者算法始终在进化）
    c.需要屏蔽算法规则的场景。（太多的算法你只要知道一个名字就可以了，传递相关的数字进来，反馈一个运算结果，万事大吉）

    例如：
    a.商品打折计算结算金额，不同的打折方式就可认为是不同的算法。
    b.播放器播放音频列表，由于不同的播放模式，通过算法计算不同的音频列表。

##### 模板方法模式
1、描述：

    定义一个操作中的算法骨架，而将一些步骤延迟到子类中，模板方法使得子类可以不改变一个算法结构即可重定义该算法的某些特定步骤。

2、优缺点：

    a、封装不变点，扩展可变部分
    b、提取公共部分代码，便于维护
    c、行为有父类控制，子类实现 

3、举例：

    a、多个子类有公有的方法，并且逻辑基本相同时。
    b、重要、复杂的算法，可以把核心算法设计为模板方法，周边的相关细节功能则由各个子类实现。
    c、重构时，模板方法模式是一个经常使用的模式，把相同的代码抽取到父类中，然后通过钩子函数（见“模板方法模式的扩展”）约束其行为。
    例如：
        a、在 Android 倍川项目中 BaseActivity 中定义了一些模板，然后子类继承，实现initView,initData等方法
        b、制造悍马

##### 观察者模式 *
1、描述：

    定义一种一对多的依赖关系，让多个观察者对象同时监听某一个主题对象。这个主题对象在状态发生改变时，会通知所有观察者对象，使他们能够自动更新自己。

2、优缺点：

    a.观察者和被观察者之间是抽象耦合
    b.建立一套触发机制
    c.多个观察者，开发和调试就会比较复杂，而且在Java中消息的通知默认是顺序执行，一个观察者卡壳，会影响整体的执行效率。在这种情况下，一般考虑采用异步的方式。
    d.多级触发时的效率更是让人担忧，大家在设计时注意考虑。

3、举例：

    a.员工观察上级，发现上级立即认真工作。
    b.电台在广播，你可以打开一个收音机，或者两个收音机来收听，电台就是被观察者，收音机就是观察者。

##### 迭代子模式
1、描述：

    提供一种方法顺序访问一个聚合对象中各个元素，而不是暴露该对象的内部表示。

2、优缺点：

    使集合的遍历简单起来。

3、举例：

    在java中，尽量不要自己写迭代器模式！省省吧，使用Java提供的Iterator一般就能满足你的要求了。

    例如：乘车买票的例子。

##### 责任链模式
1、描述：

    使多个对象都有机会处理请求，从而避免请求的发送者和接受者之前的耦合关系。将这个对象连成一条链，并沿着这条链传递该请求，直到有一个对象处理它为止。

2、优缺点：

    a、当客户提交一个请求时，请求是沿链传递直至有一个ConcreteHandler对象负责处理它。
    b、接收者和发送者都没有对方的明确信息，且链中的对象自己也并不知道链的结构。结果是职责链可简化对象的相互连接，它们仅需保持一个指向其后继者的引用，而不需保持它所有的候选接受者的引用[DP]。这也就大大降低了耦合度了。
     
3、举例：

    a、向上级请假、加薪。（不同级别的管理者有处理权限不同）

##### 命令模式
1、描述：

    将一个请求封装为一个对象，从而使你可用不同的请求对客户进行参数化；对请求排队或记录请求日志，以及支持可撤销的操作。

2、优缺点：

    a、它能较容易地设计一个命令队列。
    b、在需要的情况下，可以较容易地将命令记入日志。
    c、允许接收请求的一方决定是否要否决请求。
    d、可以容易地实现对请求的撤销和重做。
    e、最关键的优点就是命令模式把请求一个操作的对象与知道怎么执行一个操作的对象分割开。
    f、类间解耦；可扩展性；
    g、命令模式可以结合责任链模式，实现命令族解析任务；
    h、结合模板方法模式，则可以减少Command子类的膨胀问题。
    i、Command的子类：如果有N个命令，问题就出来了，Command的子类就可不是几个，而是N个，这个类膨胀得非常大，这个就需要读者在项目中慎重考虑使用。

3、举例： 

    只要你认为是命令的地方就可以采用命令模式

    例如：
    a、吃烧烤：烤牛肉命令，烤羊肉命令，烧烤员，服务员；

##### 备忘录模式 *
1、描述：

    在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态。这样以后就可将该对象恢复到原先保存的状态。

2、优缺点：

    可以保存一个对象的状态。

3、举例：

    需要保存和恢复数据的相关状态场景。提供一个可回滚（rollback）的操作；

    例如：
        a.保存游戏进度，Word中的CTRL+Z组合键，IE浏览器中的后退按钮，文件管理器上的backspace键等。
        b.移动开发中，使用数据库保存一些数据，当用户网络差再次启动时可以看到之前生成的数据，应该就类似备忘录模式。
        c.iOS 备忘录模式实现编辑框回退功能 
        d.文章详情页阅读位置，下次阅读滚动到上次阅读到的位置。

##### 状态模式
1、描述：

    当一个对象的内在状态改变时允许改变其行为，这个对象看起来像是改变了其类。

    状态模式主要解决的是当控制一个对象状态转换的条件表达式过于复杂时的情况。把状态的判断逻辑转移到表示不同状态的一系列类当中，可以把复杂的判断逻辑简化。

    与职责链模式相比最大的区别就是：
        a、状态模式是让各个状态对象自己知道其下一个处理的对象是谁，即在编译时便设定。相当于If ，else-if，else-if……， 设计思路是把逻辑判断转移到各个State类的内部实现(相当于If，else If)，执行时客户端通过调用环境—Context类的方法来间接执行状态类的行为，客户端不直接和状态交互。

        b、职责链模式中的各个对象并不指定其下一个处理的对象到底是谁，只有在客户端才设定某个类型的链条，请求发出后穿越链条，直到被某个职责类处理或者链条结束。本质相当于swich-case，设计思路是把各个业务逻辑判断封装到不同职责类，且携带下一个职责的对应引用，但不像状态模式那样需要明确知道这个引用指向谁，而是在环境类设置链接方式或者过程。

        c、责任链模式对遵守开放封闭原则，不同级别之间没有耦合。相比状态模式，责任链模式将必要的对象创建转移到客户端进行。类似工厂模式与简单工厂的区别。

2、优缺点：

    a、状态模式的好处是将与特定状态相关的行为局部化，并且将不同状态的行为分割开来[DP]。
    b、状态模式通过把各种状态转移逻辑分布到State的子类之间，来减少相互间的依赖，好比把整个版面改成了一个又一个的活字，此时就容易维护和扩展了。”
    c、很好地体现了开闭原则和单一职责原则，每个状态都是一个子类，你要增加状态就要增加子类，你要修改状态，你只修改一个子类就可以了。

3、举例：

    a、当一个对象的行为取决于它的状态，并且它必须在运行时刻根据状态改变它的行为时，就可以考虑使用状态模式了。这样做的目的就是为了消除庞大的条件分支语句。
    b、条件、分支判断语句的替代者
    c、行为随状态改变而改变的场景

    例如：工作状态，不同的时间段不同的工作状态。
 
##### 访问者模式
1、描述：

    表示一个作用于某对象结构中的各元素的操作。它使你可以在不改变各元素的类的前提下定义作用于这些元素的新操作。

2、优缺点：

    a、优点就是增加新的操作很容易，因为增加新的操作就意味着增加一个新的访问者。访问者模式将有关的行为集中到一个访问者对象中。
    b、缺点其实也就是使增加新的数据结构变得困难了。

3、举例：

    例如：男人女人结婚时分别具有不同的反应。

##### 中介者模式
1、描述：

    用一个中介对象来封装一系列的对象交互，中介者使各对象不需要显示的互相引用，从而使其耦合松散，而且可以独立的改变他们之间的交互。

2、优缺点：

    a、Mediator的出现减少了各个Colleague的耦合，使得可以独立地改变和复用各个Colleague类和Mediator

3、举例：

    中介者模式一般应用于一组对象以定义良好但是复杂的方式进行通信的场合，比如刚才得到的窗体Form对象或Web页面aspx，以及想定制一个分布在多个类中的行为，而又不想生成太多的子类的场合。

    例如：
        安理会做中介

##### 解释器模式
1、描述：

    给定一个语言，定义它的文法的一种表示，并定义一个解释器，这个解释器使用该表示来解释语言中的句子。

2、优缺点：

    a、解释器是一个简单语法分析工具，它最显著的优点就是扩展性，修改语法规则只要修改相应的非终结符表达式就可以了，若扩展语法，则只要增加非终结符类就可以了。
    b、解释器模式会引起类膨胀
    c、解释器模式采用递归调用方法
    d、效率问题

3、举例：

    a、重复发生的问题可以使用解释器模式
    b、一个简单语法需要解释的场景 
    
    例如：音乐解释器。
