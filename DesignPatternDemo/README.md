# 设计模式
学习记录，Demo

### 6大设计原则

##### 单一原则

1、描述：

    就一个类而言，应该只有一个引起他变化的原因。（单一职责适用于接口、类，同时也适用于方法）

2、优点：

    类的复杂性降低，实现什么职责都有清晰明确的定义；
    可读性提高，复杂性降低，那当然可读性提高了；
    可维护性提高，可读性提高，那当然更容易维护了；
    变更引起的风险降低，如果接口的单一职责做得好，一个接口修改只对相应的实现类有影响，对其他的接口无影响，这对系统的扩展性、维护性都有非常大的帮助。

3、不遵守会存在的问题：

    如果一个类承担的职责过多，就等于把这些职责耦合在一起，一个职责的变化可能会削弱或者抑制这个类完成其他职责的能力。
    这种耦合会导致脆弱的设计，当变化发生时，设计会遭受到意想不到的破坏[ASD]

4、如何做到：
    建议所有接口、方法一定要做到单一职责，类的设计尽量做到只有一个原因引起变化。

    软件设计真正要做的许多内容，就是发现职责并把那些职责相互分离[ASD]。
    如果你能够想到多于一个的动机去改变一个类，那么这个类就具有多于一个的职责[ASD]，就应该考虑类的职责分离。
    例如：游戏的逻辑就应该与界面进行分离。

##### 开闭原则
1、描述：

    对于软件实体（类，模块，函数等）应该允许扩展，但是不可以修改。（对扩展是开放的，对修改是封闭的）

2、优点：

    面对需求的改变却可以保持相对稳定，从而使得系统可以在第一个版本以后不断推出新的版本。
    开放-封闭原则是面向对象设计的核心所在。遵循这个原则可以带来面向对象技术所声称的巨大好处，也就是可维护、可扩展、可复用、灵活性好。开发人员应该仅对程序中呈现出频繁变化的那些部分做出抽象，然而，对于应用程序中的每个部分都刻意地进行抽象同样不是一个好主意。拒绝不成熟的抽象和抽象本身一样重要[ASD]。
 
3、不遵守会存在的问题：

    面对需求的改变越来越多，难以保持相对稳定，到后期可能导致项目维护困难重重。

4、如何做到：

    面对需求，对程序的改动是通过增加新代码进行的，而不是更改现有的代码[ASD]。 

    绝对的对修改关闭是不可能的。无论模块是多么的‘封闭’，都会存在一些无法对之封闭的变化。既然不可能完全封闭，设计人员必须对于他设计的模块应该对哪种变化封闭做出选择。他必须先猜测出最有可能发生的变化种类，然后构造抽象来隔离那些变化[ASD]。

    我们是很难预先猜测，但我们却可以在发生小变化时，就及早去想办法应对发生更大变化的可能。也就是说，等到变化发生时立即采取行动[ASD]。
 
    在我们最初编写代码时，假设变化不会发生。当变化发生时，我们就创建抽象来隔离以后发生的同类变化[ASD]。

    例如：在收费例子中，使用简单工厂模式创建不同的收费类（正常，打折。返利），但这个模式只是解决对象的创建问题。
    由于工厂本身包括了所有的收费方式，商场是可能经常性地更改打折额度和返利额度，每次维护或扩展收费方式都要改动这个工厂。为了解决这个问题，使用简单工厂与策略模式结合来解决。简单工厂模式需要让客户端认识两个类，CashSuper和CashFactory，而策略模式与简单工厂结合的用法，客户端就只需要认识一个类CashContext就可以了。
 
##### 里氏替换原则
1、描述：

    子类型必须能够替换掉他们的父类型

2、优点：

    只有当子类可以替换掉父类，软件单位的功能不受到影响时，父类才能真正被复用，而子类也能够在父类的基础上增加新的行为。
    由于子类型的可替换性才使得使用父类类型的模块在无需修改的情况下就可以扩展。

3、不遵守会存在的问题：

    如果子类不能替换父类，那么就无法实现继承复用。

4、如何做到：
    在项目中，采用里氏替换原则时，尽量避免子类的“个性”，一旦子类有“个性”，这个子类和父类之间的关系就很难调和了，把子类当做父类使用，子类的“个性”被抹杀——委屈了点；把子类单独作为一个业务来使用，则会让代码间的耦合关系变得扑朔迷离——缺乏类替换的标准。

    注意： 如果子类不能完整地实现父类的方法，或者父类的某些方法在子类中已经发生“畸变”，则建议断开父子继承关系，采用依赖、聚集、组合等关系代替继承。

##### 依赖倒置原则
1、描述：

    高层模块不应该依赖低层模块，两者都应该依赖其抽象；抽象不应该依赖细节；细节应该依赖抽象。
    Java语言中的表现就是：
        模块间的依赖通过抽象发生，实现类之间不发生直接的依赖关系，其依赖关系是通过接口或抽象类产生的；
        接口或抽象类不依赖于实现类；
        实现类依赖接口或抽象类。
        更加精简的定义就是“面向接口编程”——OOD（Object-Oriented Design，面向对象设计）的精髓之一。

2、优点：

    可以减少类间的耦合性，提高系统的稳定性，降低并行开发引起的风险，提高代码的可读性和可维护性。

3、不遵守会存在的问题：

    类之间耦合性高，稳定性下降，并行开发风险大，维护性差。

4、如何做到：

    面向接口编程。
    例如：k线图组件开发，组件一些必要的数据使用接口协议定义，让使用该组件的模块实现这些必要的接口，从而让k线图组件获得绘制k线所需的必要数据。这样就避免了k线图组件对使用该组件的数据依赖，降低了耦合性。

##### 接口隔离原则
1、描述：

    客户端不应该依赖它不需要的接口；类间的依赖关系应该建立在最小的接口上。
    接口隔离原则与单一职责的审视角度是不相同的，单一职责要求的是类和接口职责单一，注重的是职责，这是业务逻辑上的划分，而接口隔离原则要求接口的方法尽量少。

2、优点：

    接口的方法尽量少。

3、不遵守会存在的问题：

    有缺陷。如果一个接口过于庞大了，容纳了一些可变的因素，而实现接口的类并不想将全部方法实现，这时候这个接口就封装过度了。

4、如何做到：

    接口尽量细化，同时接口中的方法尽量少；
    一个接口只服务于一个子模块或业务逻辑；
    已经被污染了的接口，尽量去修改，若变更的风险较大，则采用适配器模式进行转化处理；

    例如：星探搜索美女的例子。气质型、外貌型这2种类型的特质都属于美女，但是不同类型的特质（脸好看，身材好，气质好）就应该在不同的接口。外貌接口：脸好看，身材好； 气质接口：气质好。

##### 迪米特原则
1、描述：

    如果两个类不必彼此直接通信，那么这两个类就不应该发生直接t的相互作用。如果其中一个类需要调用另外一个类的某一个方法，可以通过第三者转发这个调用。

    一个对象应该对其他对象有最少的了解。通俗地讲，一个类应该对自己需要耦合或调用的类知道得最少，你（被耦合或调用的类）的内部是如何复杂都和我没关系，那是你的事情，我就知道你提供的这么多public方法，我就调用这么多，其他的我一概不关心。

2、优点： 

    迪米特法则的核心观念就是类间解耦，弱耦合，只有弱耦合了以后，类的复用率才可以提高

3、不遵守会存在的问题：

    类之间耦合过高，无法复用。

4、如何做到：

    一个类只和朋友交流，不与陌生类交流，不要出现getA().getB().getC().getD()这种情况（在一种极端的情况下允许出现这种访问，即每一个点号后面的返回类型都相同），类与类之间的关系是建立在类间的，而不是方法间，因此一个方法尽量不引入一个类中不存在的对象，当然，JDK API提供的类除外。
    例如：老师要体育委员清点女生人数。老师只要依赖体育委员，让体育委员去依赖女生。


### 创建型设计模式 
    对象实例化的模式，创建型模式用于解耦对象的实例化过程

##### 简单工厂模式
1、描述：
    
    用一个单独的类来做这个创造实例的过程。根据客户端的选择条件动态实例化相关的类。

2、优缺点：

    a.简单工厂模式的最大优点在于工厂类中包含了必要的逻辑判断，根据客户端的选择条件动态实例化相关的类，对于客户端来说，去除了与具体产品的依赖。
    b.违背了开放-封闭原则。因为要增加新的运算，必须修改工厂内部的switch分支。

3、举例：

    简单的计算器实现。传入不同操作符，创建不同的运算类。

##### 工厂方法模式
1、描述：

    定义一个用于创建对象的接口，让子类决定实例化哪一个类。工厂方法使一个类的实例化延迟到其子类。
    相比简单工厂，工厂方法把简单工厂的内部逻辑判断移到了客户端代码来进行。这样想增加功能时，本来是修改工厂的，现在只需要修改客户端。
 
2、优缺点：

    工厂方法克服了简单工厂违背开放-封闭原则的缺点，又保持了封装对象创建过程的优点。

3、举例：

    简单的计算器实现。遵守开放-封闭原则，增加计算类。

##### 抽象工厂模式 
1、描述：

    提供一个创建一系列相关或相互依赖对象的接口，而无需指定他们的类。

2、优缺点：

    a.最大的好处便是易于交换产品系列，由于具体工厂类，例如IFactory factory = new AccessFactory（），在一个应用中只需要在初始化的时候出现一次，这就使得改变一个应用的具体工厂变得非常容易，它只需要改变具体工厂即可使用不同的产品配置。
    b.它让具体的创建实例过程与客户端分离，客户端是通过它们的抽象接口操纵实例，产品的具体类名也被具体工厂的实现分离，不会出现在客户代码中。
    c.增加功能时，需要更改的地方多，不利于扩展。

3、举例：

    数据库替换的例子。
    

##### 单利模式
1、描述：

2、优缺点：

3、举例：

##### 建造者模式
1、描述：

2、优缺点：

3、举例：

##### 原型模式
1、描述：

2、优缺点：

3、举例：

### 结构型设计模式 
    把类或对象结合在一起形成一个更大的结构

##### 适配器模式
1、描述：

2、优缺点：

3、举例：

##### 装饰器模式
1、描述：

2、优缺点：

3、举例：

##### 代理模式
1、描述：

2、优缺点：

3、举例：

##### 外观模式
1、描述：

2、优缺点：

3、举例：

##### 桥接模式
1、描述：

2、优缺点：

3、举例：

##### 组合模式
1、描述：

2、优缺点：

3、举例：

##### 享元模式
1、描述：

2、优缺点：

3、举例：


### 行为型设计模式 
    类和对象如何交互，及划分责任和算法

##### 策略模式
1、描述：

2、优缺点：

3、举例：

##### 模板方法模式
1、描述：

2、优缺点：

3、举例：

##### 观察者模式
1、描述：

2、优缺点：

3、举例：

##### 迭代子模式
1、描述：

2、优缺点：

3、举例：

##### 责任链模式
1、描述：

2、优缺点：

3、举例：

##### 命令模式
1、描述：

2、优缺点：

3、举例：

##### 备忘录模式
1、描述：

2、优缺点：

3、举例：

##### 状态模式
1、描述：

2、优缺点：

3、举例：

##### 访问者模式
1、描述：

2、优缺点：

3、举例：

##### 中介者模式
1、描述：

2、优缺点：

3、举例：

##### 解释器模式
1、描述：

2、优缺点：

3、举例：
